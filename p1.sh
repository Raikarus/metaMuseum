#/bin/bash

################
# Скрипт начального индексирования файлов изображений
# Этап 1
#
# На заданном во входном аргументе разделе создаются выделенные подкаталоги,
# в которые создаются жёсткие ссылки всех обнаруженных
# на разделе изображений форматов jpg (jpeg), png, tif (tiff), raw.
# Типы файлов опознаются по расширениям.
#
# Суммарный размер файлов (жёстих ссылок) в каждом выделенном подкаталоге
# не должен превышать размера одного диска BR-R (25 ГБ).
# Это должно быть задано в тексте конфигурационного скрипта.
#
# Жёсткими ссылками задаются уникальные номера файлам
# для учёта их в БД.
#
# Подкаталоги хранения файлов и их имена превращаются
# в первичные теги, которые заносятся в БД.
#
# Также предпринимается попытка извлечения тегов из полей EXIF (XMP)
# по заранее заданным в конфигурации БД типам.
# (Требуется вспомогательный файл ns1.xmp).
# При их наличии, они также заносятся в БД.
#
# Кроме того, основываясь на структуре подкаталогов и именах файлов
# (по соглашениям МИДД без проверки реальных изображений!), 
# скрипт выполняет в БД "привязку" файлов raw, tif, png к файлам jpg.
#


################
# Читаем файл конфигурации
. p.sh.conf

################
# Список поддерживаемых тегов (включая дубликаты)
# Индекс - пара кодов tag_id,tag_prt таблицы tags БД
declare -A tags
# Вспомогательный массив количества tag_prt в каждом tag_id
declare -a tags_lens
# Вспомогательный массив типов tag_id
declare -a tags_types
# Список имён полей таблицы pics, связанный по индексам tag_id с tags программы
declare -a tags_names

################
# Список всех уже существующих ключевых слов/фраз
# Два массива: кодов тегов и порядковых номеров тегов
# У обоих индекс - само слово/фраза
declare -A kw_tag_ids
declare -A kw_tag_ids_nums
# Текущее максимальное значение в kw_tag_ids_nums
declare kw_ind=0
# tag_id для ключвых слов (XMP-dc:Subject)
declare kword_tag_id

################
################
# Захватить БД в монопольное пользование на запись или отказаться от работы.
# Здесь же отследить ошибку при обращении к БД.
# Наиболее вероятными являются ошибки отсутствия таблиц
# или невозможности связаться с самой БД.
# Если здесь ошибок не произошло, то дальше их возникновение маловероятно,
# и их можно не проверять (это очень неудобно делать)
#
# Здесь же проверить наличие в БД записи в таблице tags
# для XMP-dc:Subject
# Если такой записи нет, то нельзя будет запоминать ключевые слова/фразы,
# поэтому работу необходимо прервать до устранения проблемы.
function lock_db ()
{
local zapros
local t

zapros="select tag_id from tags where tag_path like '%XMP-dc:Subject%'"
t=`psql -U sch -h $DBHOST -d $DBNAME -q -t -A -F "|" -c  "${zapros}"`
if [ $? -ne 0 ]
then
	echo Ошибка доступа к БД
	exit 1
fi
if [ $t -ne 10 ]
then
	echo Значение поля tag_id для поля tag_path с подстрокой \'XMP-dc:Subject\'
	echo таблицы tags должно быть равно 10 \(получено $t\)   
	exit 1
fi
kword_tag_id=10

zapros="update locktable set lockfield=lockfield+1"
psql -U sch -h $DBHOST -d $DBNAME -q -t -A -F "|" -c "${zapros}"
if [ $? -ne 0 ]
then
	echo Ошибка захвата БД
	exit 1
fi

zapros="select lockfield from locktable"
t=`psql -U sch -h $DBHOST -d $DBNAME -q -t -A -F "|" -c  "${zapros}"`
if [ $t -gt 1 ]
then
	echo БД занята
	exit 1
fi
}

################
################
# Освободить БД
function free_db ()
{
local zapros

zapros="update locktable set lockfield=0"
psql -U sch -h $DBHOST -d $DBNAME -q -t -A -F "|" -c "${zapros}"
}

################
################
# Прочитать следующий уникальный номер картинки
function get_BCNT ()
{
local zapros

zapros="select max(pic_id)+1 from pics"
BCNT=`psql -U sch -h $DBHOST -d $DBNAME -q -t -A -F "|" -c "${zapros}"`
}

################
################
# Прочитать из БД все поддерживаемые типы тегов
# и заполнить все служебные массивы
function get_TAGS ()
{
local zapros
local tind
local tprt
local tpath
local tname
local pname
local ttype
local tlen
local tnum
local kw
local OIFS
	# Требуется прочитать таблицы БД:
	#	tags - пути альтернатив выборки значений тегов
	#	kwords - уже имеющиеся ключевые слова и др.

	# Не требуется читать таблицы:
	#	pics - из неё нужен только максимальный pic_id
	#		(он уже считан ранее)
	#	gkwords - группы ключевых слов при первоначальном разборе
	#		тегов картинок не нужны
	#	pictags - таблица сопоставления kwords и pics
	#		здесь будет только занесение новой информации

	#### Читаем tags###

	# Запросить количество альтернатив каждого тега
	# Поля разделяем символом "|"
	zapros="select tag_id,count(tag_id) from tags where tag_id!=0 group by tag_id order by 1";
	while read i
	do
		# Комментарий как это работает, см. ниже
		IFS="|" read tind tlen <<< "${i}"
		tags_lens[$tind]=$tlen
	done < <(
		psql -U sch -h $DBHOST -d $DBNAME -q -t -A -F "|" -c "${zapros}"
		)
	#echo "-c-"${tags_lens[@]}

	# Запросить собственно альтернативы
	# Поля разделяем символом "|"
	zapros="select tag_id,tag_prt,tag_path,tag_name,pics_name,tag_type from tags";
	while read i
	do
		# Здесь очень важны кавычки вокруг "${i}"
		# Без кавычек по ${i} происходит автозамена | на пробел
		# в полном соответствии со значением IFS,
		# но read при этом продолжает ожидать в качестве разделителя |
		#
		# IFS в одной строке с read остаётся локальным для этой строки
		# и автоматически восстанавливается для следующих строк
		#
		IFS="|" read tind tprt tpath tname pname ttype <<< "${i}"
		tags[$tind,$tprt]=$tpath
		tags_types[$tind]=$ttype
		tags_names[$tind]=$pname
	done < <(
		psql -U sch -h $DBHOST -d $DBNAME -q -t -A -F "|" -c "${zapros}"
		)
	#echo "-t-"${tags[@]}
	#echo "-p-"${tags_names[@]}

	#### Читаем kwords###
	# Поля разделяем символом "|"
	zapros="select tag_id,tag_id_num,kword_name from kwords";
	while read i
	do
		# По поводу "${i}" и IFS  см. комментарий выше
		IFS="|" read tind tnum kw <<< "${i}"
		if [ -n "${kw}" ]
		then
			kw_tag_ids[$kw]=$tind
			kw_tag_ids_nums[$kw]=$tnum

			if [ $kw_ind -lt $tnum ]
			then
				kw_ind=$tnum
			fi
		fi
	done < <(
		psql -U sch -h $DBHOST -d $DBNAME -q -t -A -F "|" -c "${zapros}"
		)
	#echo "-ki-"${kw_tag_ids[@]}
	#echo "-kin-"${kw_tag_ids_nums[@]}
}


################
################
# Считать теги/ключевые слова из картинки
# и из пути файла картинки
# и записать в БД
#
# Здесь же подобрать подкаталог тома
# и проставить в него жёсткую ссылку на файл
#
function set_TAGS_from_picture ()
# $1 - имя файла картинки (полный путь)
# $2 - если "jpg", значить надо искать "парные" файлы tiff, png, raw
#	и также ставить на них ссылки, попутно отмечая в БД
{
local XMLFILE
local cnttags
local zapros

local i
local j
local k
local a

# Определить пустые массивы (локальные):
# - для значений в поля pics
declare -A ptags
# - для ключевых слов/фраз
declare -A ktags
declare -A ktags_nums

# Показать обрабатываемый файл
echo $1

#####################################################
# Считать все теги в формате XML во временный файл
XMLFILE=/tmp/xmp.$$
exiftool -ALL -X "$1" >$XMLFILE

#####################################################
# узнаем количество считываемых тегов
cnttags=${#tags_lens[@]}
#
# попутно соберём запрос для ввода в БД новых ключевых слов/фраз
# (здесь начало)
#####################################################
zapros="insert into kwords (tag_id,tag_id_num,kword_name) values"
local z=""
local zv=""
# цикл по тегам
for ((i=1 ; i<=$cnttags ; i++))
do
	# цикл по альтернативам каждого тега
	for ((j=1 ; j<=${tags_lens[$i]} ; j++))
	do
#echo "!-tn- @"${tags_names[$i]}"@"
		case ${tags_types[$i]} in
		0)
			# поля для таблицы pics
			read a <<< $(
			cat $XMLFILE |
			xmlstarlet sel `cat ns1.xmp` -t -v "${tags[$i,$j]}"
			)
#echo "!-tn1- @${tags[$i,$j]}"
#echo "!-tn1- @$a"
			if [ -n "$a" ]
			then
				ptags[${tags_names[$i]}]="$a"
				break
			fi
			;;
		1)
			# поля геотегов
			# пока игнорируем
			;;
		2)
			# ключевые слова/фразы
#echo "!-tnk- @${tags[$i,$j]}"
			while read k
			do
#echo "!-tnk- @${k}"
				if [ ${kw_tag_ids[$k]:-_} == $i ]
				then
					# такое ключевое слово уже есть
					ktags[${k}]=$i
					ktags_nums[${k}]=${kw_tag_ids_nums[$k]}
				else
					# проверим, вдруг уже присвоили
					# на предыдущей итерации?
					#Index_Exist ktags "$k"
					#if [ $? -eq 0 ]
					if ! [ ${ktags[$k]:-0} -gt 0 ]
					then
						# это новое ключевое слово

						# найти максимальное значение номера
					#	local ind=0
					#	local is
#echo "!-k0- @${!kw_tag_ids[@]}"
					#	for is in "${!kw_tag_ids[@]}"
					#	do
#echo "!-k- @${is}@$i@${kw_tag_ids[$is]}"
					#		if [ ${kw_tag_ids[$is]} -eq $i ] && [ $ind -lt ${kw_tag_ids_nums[$is]} ]
					#		then
					#			ind=${kw_tag_ids_nums[$is]}
					#		fi
					#	done

						kw_ind=$(( $kw_ind + 1 ))
						ktags[${k}]=$i
						kw_tag_ids[${k}]=$i
						ktags_nums[${k}]=$kw_ind
						kw_tag_ids_nums[${k}]=$kw_ind
						# дополняем запрос
						if [ -n "$z" ]
						then
							zv=${zv}","
						fi
						# В строке тега (${k})
						# может встречаться символ апострофа (одиночной кавычки),
						# что фатально для записи в БД,
						# так как записываемая строка обязательно
						# должна браться именно в апострофы.
						# Решением для SQL является удвоение апострофа
						# (самым сложным оказалось подобрать для него шаблон поиска)
						z=" ( ${i},${kw_ind},'${k//\'/''}')"
						zv=${zv}${z}
					fi
				fi
			done < <( 
			cat $XMLFILE |
			xmlstarlet sel `cat ns1.xmp` -t -v "${tags[$i,$j]}"
			)
#echo "!-kw- @"${ktags[@]}
#echo "!-kwn- @"${ktags_nums[@]}
#echo "!-kwz- @$zv"
			;;
		esac

	done
done

#####################################################
# В качестве ключевых слов/фраз добавим также фразы
# из имён подкаталогов пути к файлу и имени самого файла
# (то есть, продолжение)
#####################################################
	# К сожалению, поиск удаляемой подстроки работает только
	# по шаблонам, применяемым в командной строке 
	# (не по регулярным выражениям)
	#
	# Поэтому придётся немного извратиться,
	# чтобы учесть файлы, пути к которым МОГУТ содержать точки,
	# а сами имена файлов точек (расширений) не содержат
	local fcmnd
	local ftags
	local j1=${1##*/}
	local jb=${j1##*.}
	if [ "$j1" = "$jb" ]
	then
		# нет расширения
		printf -v fcmnd "p%017d.full"  ${BCNT}
		# Остальное считать основой тегов
		ftags=$1
	else
		# есть расширение
		printf -v fcmnd "p%017d.full.%s"  ${BCNT} "${jb,,}"
		# Отсечь расширение - остальное считать основой тегов
		ftags=${1%.*}
	fi

	# Выделить теги (имена подкаталогов и самого файла без расширения)
	# в индексный массив
	IFS="/" read -a mstags <<< "${ftags}"
	
	# используем ассоциативный массив для отсеивания дубликатов
	declare -A amstags
	for ti in "${mstags[@]}"
	do
#echo $ti
		amstags[$ti]=1
	done
	# проверим, что выбрали правильно (должны остатья пробелы внутри тегов)
#echo ____________
	# здесь нужны не значения элементов, а ключи (индексы)
	for ti in "${!amstags[@]}"
	do
		#echo $ti
#echo "!-tnk- @${ti}"
#echo "!-tnk1- @${kword_tag_id}"
		if [ ${kw_tag_ids[$ti]:-_} == $kword_tag_id ]
		then
			# такое ключевое слово уже есть
			ktags[${ti}]=$kword_tag_id
			ktags_nums[${ti}]=${kw_tag_ids_nums[$ti]}
		else
			# проверим, вдруг уже присвоили
			# на предыдущей итерации?
			if ! [ ${ktags[$ti]:-0} -gt 0 ]
			then
				# это новое ключевое слово

				# найти максимальное значение номера
			#	local ind=0
			#	local is
#echo "!-k0- @${!kw_tag_ids[@]}"
#echo "!-k0- @${!kw_tag_ids[@]}"
#echo "!-k01- @${kw_tag_ids_nums[@]}"
			#	for is in "${!kw_tag_ids[@]}"
			#	do
#echo "!-k- @${is}@$i@${kw_tag_ids[$is]}"
			#		if [ ${kw_tag_ids[$is]} -eq $kword_tag_id ] && [ $ind -lt ${kw_tag_ids_nums[$is]} ]
			#		then
			#			ind=${kw_tag_ids_nums[$is]}
			#		fi
			#	done

				kw_ind=$(( $kw_ind + 1 ))
				ktags[${ti}]=$kword_tag_id
				kw_tag_ids[${ti}]=$kword_tag_id
				ktags_nums[${ti}]=$kw_ind
				kw_tag_ids_nums[${ti}]=$kw_ind
				# дополняем запрос
				if [ -n "$z" ]
				then
					zv=${zv}","
				fi
				# В имени файла или подкаталога (${ti})
				# может встречаться символ апострофа (одиночной кавычки),
				# что фатально для записи в БД,
				# так как записываемая строка обязательно
				# должна браться именно в апострофы.
				# Решением для SQL является удвоение апострофа
				# (самым сложным оказалось подобрать для него шаблон поиска)
				z=" ( ${kword_tag_id},${kw_ind},'${ti//\'/''}')"
				zv=${zv}${z}
			fi
		fi
	done
#echo ^^^^^^^^^^^^
	#unset mstags
	unset amstags


#echo "!-zkw- @"$zapros$zv
#####################################################
# Начинаем транзакцию
#
# Чтобы транзакция получилась, все запросы соберём в одну большую строку
#####################################################
local ZaprTran="begin transaction; "

#####################################################
# Добавить в БД новые ключевые слова
#####################################################
if [ -n "${zv}" ]
then
	ZaprTran=${ZaprTran}${zapros}${zv}"; "
fi


#####################################################
# Выполняем запись о новой картинке в таблицу pics
#####################################################

# Для записи в БД даты/времени в теге картинки ожидается "гггг:мм:дд чч:мм:сс"
# Отсечь зону, если она есть
ptags[date]=${ptags[date]%+*}
# Откорректируем запись даты из "гггг:мм:дд чч:мм:сс" в "гггг-мм-дд чч:мм:сс"
# Если оказалось, что поле в теге имеет не такой формат, 
# не записывать дату/время в БД
# Проверяем по регулярному выражению
local pattern='....:..:.. ..:..:..'
if [[ ${ptags[date]} =~ $pattern ]]
then
	#${BASH_REMATCH[]}
	# Заменить первые два символа : на -
	ptags[date]=${ptags[date]/:/-}
	ptags[date]=${ptags[date]/:/-}
else
	# Аннулировать значение поля тега
	ptags[date]=
fi

# Здесь надо определить подкаталог,
# в который будет сделана жёсткая ссылка на файл.

# Заполнить поле размера файла
read -a a <<< `ls -l "$1"`
ptags[fsize]=${a[4]}

# Подкаталог будет возвращён в $VOL_WR
# Его $vol_id будет возвращён по return
Get_vol_id ${ptags[fsize]}
local vol_id=$?
#echo "!----"$VOL_WR
# Саму ссылку поставим после успешной записи всего в БД

#####################################################
# Формируем zapros на запись картинки в pics
MAKE_zapros_in_pics ${BCNT} $2
#echo "!-z- @"$zapros
#####################################################
# Собственно запись в таблицу pics
#####################################################
ZaprTran=${ZaprTran}${zapros}"; "


#####################################################
# Выполняем привязку тегов к новой картинке (таблица pictags)
# (формируем zapros)
MAKE_zapros_in_pictags ${BCNT}
#####################################################
# Собственно запись в таблицу pictags
# Потенциально запрос может быть пустой, то есть записывать нечего
#####################################################
if [ -n "${zapros}" ]
then
	ZaprTran=${ZaprTran}${zapros}"; "
fi


#####################################################
# Наконец, выполняем собственно запись одной транзакцией
#####################################################
ZaprTran=${ZaprTran}"end transaction; "
psql -U sch -h $DBHOST -d $DBNAME -q -t -A -F "|" -c "${ZaprTran}"
if [ $? -ne 0 ]
then
	echo Ошибка записи в БД данных по файлу ${1}
	echo Запрос: "${ZaprTran}"
	echo
	# Работу продолжать с другими картинками

	#####################################################
	# Должен получиться откат транзакции 
	# (по выходу из psql без завершения транзакции)

	return
fi

#####################################################
# Запись в БД была успешной
# Выполнить простановку жёсткой ссылки на файл
#####################################################
ln "$1" "${VOL_WR}/${fcmnd}"

local JPG_BCNT=${BCNT}
BCNT=$(( $BCNT + 1 ))
#echo "!-B- $BCNT"

# Если $2 соответствует "jpg",
# значит надо проверить наличие "парных" tif, png, raw
# и поставить соответствующие ссылки
# с отметкой в БД
if [ ${2:-_} == "jpg" ]
then
	# Имена всех подкаталогов, включая имя файла БЕЗ расширения,
	# уже выбраны ранее в массив (обычный) ${mstags[]}.
	# Проблема заключается в том, что jpg/JPG/jpeg/JPEG
	# не обязательно встретится предпоследним

	# Пройдёмся по всем подкаталогам
	# задом наперёд
	# (так как парные jpg-png, jpg-tif, jpg-raw
	# будут самые правые)
	local i=$(( ${#mstags[@]} - 1 ))
	while [ $i -gt 0 ]
	do
#echo "!!!-mt"$i"@"${mstags[$i]}
		local pattern='^[jJ][pP][eE]?[gG]$'
		if [[ "${mstags[$i]}" =~ $pattern ]]
		then
	#${BASH_REMATCH[0]}
#echo "!!!-mt~"$i"@"${mstags[$i]}
IFS="/" eval 'lft="${mstags[*]:0:$i}"'
IFS="/" eval 'rgt="${mstags[*]:$(( $i +1 ))}"'
#echo "!!!-mt-f~@"${lft}/${BASH_REMATCH[0]}/${rgt}
			# Будем проверять поочерёдно на все возможные расширения
			local sfl=""
			for ti in png PNG raw RAW tif TIF tiff TIFF
			do
#echo "!!!-"$ti
				if ! [ -d "${lft}/${ti}" ]
				then
					continue
				fi

				# Здесь теоретически возможны варианты
				# с именами подкаталогов и расширениями
				# типа tif/*.tiff и аналогично.
				# Теоретически возможно, что в подкаталоге tif
				# будет лежать файл .png или .raw...
				# И многое другое...
				# Но поскольку сервер всё же наш, собственный,
				# то будем считать, что существует строгое соответствие
				# имени подкаталога и формата файла 
				# (можно это даже потребовать и проверить
				# перед выполнением скрипта на заданном томе).

				sfl=`ls "${lft}/${ti}/${rgt}".* 2>/dev/null`
				if [ -n "${sfl}" ]
				then
#echo "!!!-~"$sfl
echo "="$sfl
					# Считаем, что нашли пару
					if [ ${ti} = tiff ] || [ ${ti} = TIFF ]
					then
						local tExt=tif
					else
						local tExt=${ti,,}
					fi
					
					#####################################################
					# Подготовить и выполнить запись в БД
					# одной транзакцией
					ZaprTran="begin transaction; "

					# Здесь надо определить подкаталог,
					# в который будет сделана жёсткая ссылка на файл.

					# Заполнить поле размера файла
					read -a a <<< `ls -l "${sfl}"`
					ptags[fsize]=${a[4]}

					# Подкаталог будет возвращён в $VOL_WR
					# Его $vol_id будет возвращён по return
					Get_vol_id ${ptags[fsize]}
					local vol_id=$?
					# Саму ссылку поставим после успешной записи всего в БД

					#####################################################
					# Формируем zapros на запись картинки в pics
					MAKE_zapros_in_pics ${BCNT} $tExt
					#echo "!-z- @"$zapros
					#####################################################
					# Собственно запись в таблицу pics
					#####################################################
					ZaprTran=${ZaprTran}${zapros}"; "


					#####################################################
					# Выполняем привязку тегов к новой картинке (таблица pictags)
					# (формируем zapros)
					MAKE_zapros_in_pictags ${BCNT}
					#####################################################
					# Собственно запись в таблицу pictags
					# Потенциально запрос может быть пустой, то есть записывать нечего
					#####################################################
					if [ -n "${zapros}" ]
					then
						ZaprTran=${ZaprTran}${zapros}"; "
					fi


					#####################################################
					# Формируем запросы на простановку перекрёстных маркеров
					#####################################################
					zapros="update pics set jpg_id=${JPG_BCNT} where pic_id=${BCNT}";
					ZaprTran=${ZaprTran}${zapros}"; "

					#####################################################
					# Наконец, выполняем собственно запись одной транзакцией
					#####################################################
					ZaprTran=${ZaprTran}"end transaction; "
					psql -U sch -h $DBHOST -d $DBNAME -q -t -A -F "|" -c "${ZaprTran}"
					if [ $? -ne 0 ]
					then
						echo Ошибка записи в БД данных по файлу ${sfl}
						echo Запрос: "${ZaprTran}"
						echo
						# Работу продолжать с другими картинками

						#####################################################
						# Должен получиться откат транзакции 
						# (по выходу из psql без завершения транзакции)

						continue
					fi

					#####################################################
					# Запись в БД была успешной
					# Выполнить простановку жёсткой ссылки на файл
					#####################################################
					printf -v fcmnd "p%017d.full.%s"  ${BCNT} "${tExt}"
					ln "${sfl}" "${VOL_WR}/${fcmnd}"

					BCNT=$(( $BCNT + 1 ))
				fi
				# Прохождение по расширениям не прекращаем,
				# поскольку возможны варианты
			done

			# Сразу после первого совпадения
			# прерываем прохождение по подкаталогам
			break
		fi
		i=$(( $i - 1 ))
	done
fi

# Удалить временный файл
rm $XMLFILE

#echo "!-p- ${ptags[@]}"
#echo "!-k- ${ktags[@]}"
#echo "!-k!- ${!ktags[@]}"
# Массивы ptags и ktags самоуничтожаются
#echo "########"
}

################
################
# Сформировать в строке $zapros запрос SQL на запись картинки в pics
#
# $1 - текущее значение $BCNT
# $2 - формат картинки для отметки в соответствующем
#	поле таблицы pics (jpg, png, tif, raw)
function MAKE_zapros_in_pics() {
if [ -n "${ptags[date]}" ]
then
#echo "!-d1-"
	# Подготовить запрос ввода с датой
	zapros="insert into pics
	(pic_id,fsize,subscr,title,width,height,date,rights,vol_id,fmt) 
	values
	($1,${ptags[fsize]},
	'${ptags[subscr]}','${ptags[title]}',
	${ptags[width]},${ptags[height]},
	'${ptags[date]}','${ptags[rights]}',
	$vol_id,'$2')
	"
else
#echo "!-d2-"
	# Подготовить запрос ввода без даты
	zapros="insert into pics
	(pic_id,fsize,subscr,title,width,height,rights,vol_id,fmt) 
	values
	($1,${ptags[fsize]},
	'${ptags[subscr]}','${ptags[title]}',
	${ptags[width]},${ptags[height]},
	'${ptags[rights]}',
	$vol_id,'$2')
	"
fi
}

################
################
# Сформировать в строке $zapros запрос SQL на запись ссылок 
# на ключевые слова/фразы в pictags
#
# $1 - текущее значение $BCNT
function MAKE_zapros_in_pictags() {
# Начинаем сборку запроса к БД
zv=""
z=""
# Теги подобраны в ассоциативных массивах
# ktags и ktags_nums
# Работаем по индексам массивов, которые представляют собой
# ключевые слова/фразы (возможно, с пробелами)
#echo "!-kw- @"${ktags[@]}
#echo "!-kwi- @"${!ktags[@]}
#echo "!-kwn- @"${ktags_nums[@]}
for kwi in "${!ktags[@]}"
do
	# дополняем запрос
	if [ -n "$z" ]
	then
		zv=${zv}","
	fi
	z=" ( $1,${ktags[$kwi]},${ktags_nums[$kwi]})"
	zv=${zv}${z}
done
if [ -n "${zv}" ]
then
	zapros="insert into pictags (pic_id,tag_id,tag_id_num) values "${zv}
else
	zapros=""
fi
}

################
################
# Создать в таблице volumes первую запись о подкаталоге $VOL_IN
# и создать первый подкаталог для компоновки файлов
function Set_vol_id() {
local vol_num
	# Проверяем наличие такой записи
	# с открытым для записи томом
	local zapros="select count(dirname) from volumes where dirname like '${VOL_IN}' and lock=0"
	local t=`psql -U sch -h $DBHOST -d $DBNAME -q -t -A -F "|" -c  "${zapros}"`
	if [ $t -gt 0 ]
	then
		# Есть хотя бы одна такая запись

		# Проверить наличие подкаталогов томов,
		# в которые разрешена запись.
		# Подкаталоги томов, в которые запись уже закрыта,
		# могут отсутствовать - это не ошибка.
		zapros="select vol_id from volumes where dirname like '${VOL_IN}' and lock=0"
		for vol_num in `psql -U sch -h $DBHOST -d $DBNAME -q -t -A -F "|" -c  "${zapros}"`
		do
			if ! [ -d ${VOL_IN}/${VOLROOT}/${VOLNAME}${vol_num} ]
			then
				echo Критическая ошибка!
				echo Отсутствует ранее созданный подкаталог ${VOL_IN}/${VOLROOT}/${VOLNAME}${vol_num}
				return 1
			fi
		done

		# Всё в порядке
		return 0
	fi

	# Создать одну такую запись
	zapros="select max(vol_id)+1 from volumes"
	vol_num=`psql -U sch -h $DBHOST -d $DBNAME -q -t -A -F "|" -c  "${zapros}"`
	zapros="insert into volumes(vol_id,dirname)
		values($vol_num,'${VOL_IN}') 
		"
	psql -U sch -h $DBHOST -d $DBNAME -q -t -A -F "|" -c  "${zapros}"

	# Создать подкаталог
	mkdir -p "${VOL_IN}/${VOLROOT}/${VOLNAME}${vol_num}"

	# Всё в порядке
	return 0
}

################
################
# Подобрать (создать) подкаталог тома 
# для размещения файла на внешнем носителе
# Вернуть по return $vol_id
function Get_vol_id() {
# $1 - размер обрабатываемого файла в байтах

local vol_num

	# Проверить наличие $VOLROOT
	if ! [ -d "${VOL_IN}/${VOLROOT}" ]
	then
		# Создать его
		mkdir -p "${VOL_IN}/${VOLROOT}"
	fi

	# Запросить имеющиеся в $VOLROOT подкаталоги томов,
	# разрешённые для записи
	local zapros="select vol_id from volumes where dirname like '${VOL_IN}' and lock=0"
	for vol_num in `psql -U sch -h $DBHOST -d $DBNAME -q -t -A -F "|" -c  "${zapros}"`
	do
		# Проверить поочерёдно возможность записи файла

		# Запросить уже занятый объём
		zapros="select sum(fsize) from pics where vol_id=${vol_num}"
		local t=`psql -U sch -h $DBHOST -d $DBNAME -q -t -A -F "|" -c  "${zapros}"`
		# Здесь возможен пустой возврат вместо числа, 
		# если не было ни одной записи в подкаталог
		t=$(( ${t:-0} + $1 ))
#echo "!-volsize@"$vol_num"@"$t"@"$VOLSIZE
		if [ ${t:-0} -le ${VOLSIZE} ]
		then
			# Подкаталог тома найден
			VOL_WR=${VOL_IN}/${VOLROOT}/${VOLNAME}${vol_num}
			return $vol_num
		fi
	done

	# Если оказались здесь, значит подходящего подкаталога нет
	# Создать новый
	zapros="select max(vol_id)+1 from volumes"
	vol_num=`psql -U sch -h $DBHOST -d $DBNAME -q -t -A -F "|" -c  "${zapros}"`
	zapros="insert into volumes(vol_id,dirname)
		values($vol_num,'${VOL_IN}') 
		"
	psql -U sch -h $DBHOST -d $DBNAME -q -t -A -F "|" -c  "${zapros}"

	# Создать подкаталог
	mkdir -p "${VOL_IN}/${VOLROOT}/${VOLNAME}${vol_num}"

	VOL_WR=${VOL_IN}/${VOLROOT}/${VOLNAME}${vol_num}
	return $vol_num
}



################
################
# Проверить наличие в ассоциативном массиве $1 индекса $2
# Результат работы функции проверять по $?
# Функция честно стянута из Интернета
# Доделано: 
# 1) в ${keys// /|} вставлен выбор "пробел" или "табуляция"
# 2) функция из Интернет не умела проверять индексы с пробелами
#	но доработка этого момента пока не понадобилась
function Index_Exist() {
	eval 'local keys=${!'$1'[@]}';
	if [ -z "$keys" ]
	then
		return 0
	fi
	eval "case '$2' in
		${keys//[ 	]/|} ) return 1 ;;
		* ) return 0 ;;
	esac";
}


##########################################################################
##########################################################################
##########################################################################
# Начало программы
##########################################################################
##########################################################################
##########################################################################
if [ $# -lt 1 ]
then
	echo "Запуск: "`basename $0`" подкаталог"
	exit 1
fi
if ! [ -d $1 ]
then
	echo Не найден подкаталог $1
	exit 1
fi

##########################################################################
# !!! Эту строчку потом убрать !!!
##########################################################################
free_db

lock_db

echo Работа

# Прочитать следующий свободный номер картинки
get_BCNT

# Запомнить входной подкаталог
VOL_IN=$1
# Создать подкаталоги для компоновки файлов в тома
Set_vol_id
if [ $? -ne 0 ]
then
	free_db
	exit 1
fi

# Прочитать из БД все поддерживаемые типы тегов
get_TAGS


# Обработать в подкаталоге $1 все файлы картинок,
# имеющие только одну жёсткую ссылку в файловой системе
# (то есть предположительно не скомпонованные в тома).
# При этом НЕ обрабатывать файлы и подкаталоги,
# начинающиеся с точки (в том числе $VOLROOT)

##########################################################################
# Сначала обрабатывем все jpg (jpeg, JPG, JPEG)
# Предполагаем, что если имеются парные картинки типа jpg-raw, jpg-png, jpg-tiff,
# то фактически это две копии одного изображения, которые должны описываться
# как одна картинка - им присваивается один кодовый номер
# (в БД одна запись, но в ФС две ссылки на два варианта изображения).
while read i
do
	# Извлечь теги и ключевые слова из картинки
	# и занести их в БД
	set_TAGS_from_picture "${i}" "jpg"
done < <(
	find $1 -xdev -type f -links 1 ! -regex '.*"/.".*' ! -regex '.*MD5' |
	grep -i -E '\.jpe?g$'
	)

##########################################################################
# Теперь обрабатываем оставшиеся без описания изображения
# с расширениями png, tiff, raw (в обоих регистрах)

##########################################################################
# png (PNG)
while read i
do
	# Извлечь теги и ключевые слова из картинки
	# и занести их в БД
	set_TAGS_from_picture "${i}" "png"
done < <(
	find $1 -xdev -type f -links 1 ! -regex '.*"/.".*' ! -regex '.*MD5' |
	grep -i -E '\.png$'
	)

##########################################################################
# tif (tiff, TIF, TIFF)
while read i
do
	# Извлечь теги и ключевые слова из картинки
	# и занести их в БД
	set_TAGS_from_picture "${i}" "tif"
done < <(
	find $1 -xdev -type f -links 1 ! -regex '.*"/.".*' ! -regex '.*MD5' |
	grep -i -E '\.tiff?$'
	)

##########################################################################
# raw (RAW)
while read i
do
	# Извлечь теги и ключевые слова из картинки
	# и занести их в БД
	set_TAGS_from_picture "${i}" "raw"
done < <(
	find $1 -xdev -type f -links 1 ! -regex '.*"/.".*' ! -regex '.*MD5' |
	grep -i -E '\.raw$'
	)


free_db

